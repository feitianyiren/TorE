<center>'''Tornado增强包（TORE）'''</center>

为了适应模板和Ajax类型的Web应用以及RESTful Web服务开发，对Tornado Web框架进行了功能上的增强，适用于Python 3.2，主要增加了以下功能：

# 内置Json Messaging消息服务器；
# 增强了模板引擎，使之支持Code Behind风格；
# 增加认证、鉴权、Json处理等其它功能；

下面是一些简要说明，具体说明参见软件注释文档。

= tore.start_server(**settings) =
功能：一步到位启动tornado服务器，tore新增并强化了tornado默认的设置，如下表所示。


{| style="border-spacing:0;"
| style="border-top:0.05pt solid #000000;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 键
| style="border-top:0.05pt solid #000000;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 值
| style="border:0.05pt solid #000000;padding:0.097cm;"| 备注

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| root_dir
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 网站根目录，其它设置中的目录均已该目录为基准，默认为当前目录（os.getcwd()）
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| handlers
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| URL映射，功能和格式与tornado.web.Application类的构造函数中的handlers参数一致，默认有以下映射：

1、/web：映射到网站的web目录，其中的文件的访问规则为：*.t文件作为模板处理；*.py文件是模板代码文件，禁止直接访问；其它文件作为静态文件转交tornado.web.StaticFileHandler处理

2、/messaging：Json Messaging消息服务的WebSocket地址，WebSocket的地址和端口是与网站共享的。

3、/：根目录直接重定向到/web/index.t，所以/web/index.t作为网站的首页必须存在
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 强化

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| port
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 网站端口，默认为80
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 强化

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| gzip
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 是否启用gzip压缩，默认不启用
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 不变

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| encryption
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 是否启用SSL加密，如果启用了SSL加密，那么必须设置certfile和keyfile参数，默认不启用
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| certfile
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| SSL公钥文件名，功能和tornado.httpserver.HTTPServer的参数是一致的，可以使用绝对路径或相对路径，如果使用相对路径，那么以root_dir为根
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| keyfile
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| SSL私钥文件名，功能和tornado.httpserver.HTTPServer的参数是一致的，可以使用绝对路径或相对路径，如果使用相对路径，那么以root_dir为根
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| debug
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| 是否启用调试，默认不启用。该参数除了具备tornado.web.Application同名参数的功能外，tore还增加了以下功能：

1、禁用调试将关闭tornado所有HTTP相关的调试输出，提高性能；

2、启用调试的时候tore.web.JsonHandler的Json输出是可读的，也就是不进行ascii转义，并且具有换行和缩进；

3、启用调试的时候每一次请求都将重新加载模板文件和对应的代码文件，禁用调试的时候只加载一次，和tornado默认的行为是一致的
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 强化

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| authentication
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| foo(username, password)格式的函数，tore.web.authenticated修饰符将会用从HTTP基本认证中获取的用户名和口令调用该函数，如果该函数存在并且调用返回值为False，那么将引发HTTP 401错误；否则设置这个用户名为当前用户名并且调用被修饰的方法。默认不存在
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| authorization
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| foo(username, path)格式的函数，tore.web.authorized修饰符将会使用当前用户名和当前请求的URL调用该函数，如果该函数存在并且调用返回值为False，那么将引发HTTP 403错误；否则调用被修饰的方法。默认不存在
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| messaging_tcp_port
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| Json Messaging消息服务的TCP端口，设置为None则禁用TCP，默认为None
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|-
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| messaging_udp_port
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:none;padding:0.097cm;"| Json Messaging消息服务的UDP端口，设置为None则禁用UDP，默认为None
| style="border-top:none;border-bottom:0.05pt solid #000000;border-left:0.05pt solid #000000;border-right:0.05pt solid #000000;padding:0.097cm;"| 新增

|}
= 模板引擎 =
tore.web.RequestHandler、tore.web.Loader、tore.web.Template分别改写了tornado.web.RequestHandler、tornado.template.Loader、tornado.template.Template，增强了Tornado自带的模板功能，一般不建议单独使用，具体改进如下：

现在模板引擎能自动寻找模板同目录下存在“模板文件名.py”文件，如果存在，则自动加载合并到模板生成的代码中，如果不存在则不加载。对于模板继承的情况，模板引擎能够自动的遍历祖先模板，然后按照祖先优先的顺序加载这些模板对应的代码文件（如果存在的话）。

现在写模板和代码就像ASP.NET的Code Behind风格一样，简单多了，不需要再像传统Tornado那样需要编写Handler然后在URL映射中进行繁琐的设置了。下面举个简单的例子，具体好处自己体会。


父模板base.t

 <nowiki><!DOCTYPE html></nowiki>
 <nowiki><html></nowiki>
 <nowiki><head></nowiki>
     <nowiki><title>{{ title }}</title></nowiki>
 <nowiki></head></nowiki>
 <nowiki><body></nowiki>
     {% block body %}{% end %}
 <nowiki></body></nowiki>
 <nowiki></html></nowiki>


父模板代码base.t.py

 <nowiki>#!/usr/bin/env python</nowiki>
 <nowiki># -*- coding: UTF-8 -*-</nowiki>
 """

 """
 __author__ = ''
 __version__ = ''

 title = request.path


子模板index.t

 {% extends "base.t" %}
 {% block body %}
 <nowiki><h1></nowiki>
     {{ hello }}
     {{ world() }}
     {{ os.getcwd() }}
 <nowiki></h1></nowiki>
 <nowiki><img src="test.jpg" alt="test"></nowiki>
 {% end %}


子模板代码index.t.py

 <nowiki>#!/usr/bin/env python</nowiki>
 <nowiki># -*- coding: UTF-8 -*-</nowiki>
 """

 """
 __author__ = ''
 __version__ = ''

 import os

 hello = 'hello'

 def world():
     return 'world'


最终子模板会自动地转换成以下Python代码，可以看到父子模板及其代码的合并是非常“和谐”的：

 def _execute():  <nowiki># base.t:0</nowiki>
     <nowiki>_buffer = [] </nowiki> <nowiki># base.t:0</nowiki>
     _append = _buffer.append  <nowiki># base.t:0</nowiki>
     <nowiki>_append(b'<!DOCTYPE html>\n<html>\n<head>\n </nowiki>   <nowiki><title>') </nowiki> <nowiki># base.t:4</nowiki>
     _tmp = title  <nowiki># base.t:4</nowiki>
     if isinstance(_tmp, _string_types): _tmp = _utf8(_tmp)  <nowiki># base.t:4</nowiki>
     else: _tmp = _utf8(str(_tmp))  <nowiki># base.t:4</nowiki>
     _tmp = _utf8(xhtml_escape(_tmp))  <nowiki># base.t:4</nowiki>
     _append(_tmp)  <nowiki># base.t:4</nowiki>
     <nowiki>_append(b'</title>\n</head>\n<body>\n </nowiki>   ')  <nowiki># base.t:7</nowiki>
     <nowiki>_append(b'\n<h1>\n </nowiki>   ')  <nowiki># index.t:4 (via base.t:7)</nowiki>
     _tmp = hello  <nowiki># index.t:4 (via base.t:7)</nowiki>
     if isinstance(_tmp, _string_types): _tmp = _utf8(_tmp)  <nowiki># index.t:4 (via base.t:7)</nowiki>
     else: _tmp = _utf8(str(_tmp))  <nowiki># index.t:4 (via base.t:7)</nowiki>
     _tmp = _utf8(xhtml_escape(_tmp))  <nowiki># index.t:4 (via base.t:7)</nowiki>
     _append(_tmp)  <nowiki># index.t:4 (via base.t:7)</nowiki>
     _append(b'\n    ')  <nowiki># index.t:5 (via base.t:7)</nowiki>
     _tmp = world()  <nowiki># index.t:5 (via base.t:7)</nowiki>
     if isinstance(_tmp, _string_types): _tmp = _utf8(_tmp)  <nowiki># index.t:5 (via base.t:7)</nowiki>
     else: _tmp = _utf8(str(_tmp))  <nowiki># index.t:5 (via base.t:7)</nowiki>
     _tmp = _utf8(xhtml_escape(_tmp))  <nowiki># index.t:5 (via base.t:7)</nowiki>
     _append(_tmp)  <nowiki># index.t:5 (via base.t:7)</nowiki>
     _append(b'\n    ')  <nowiki># index.t:6 (via base.t:7)</nowiki>
     _tmp = os.getcwd()  <nowiki># index.t:6 (via base.t:7)</nowiki>
     if isinstance(_tmp, _string_types): _tmp = _utf8(_tmp)  <nowiki># index.t:6 (via base.t:7)</nowiki>
     else: _tmp = _utf8(str(_tmp))  <nowiki># index.t:6 (via base.t:7)</nowiki>
     _tmp = _utf8(xhtml_escape(_tmp))  <nowiki># index.t:6 (via base.t:7)</nowiki>
     _append(_tmp)  <nowiki># index.t:6 (via base.t:7)</nowiki>
     <nowiki>_append(b'\n</h1>\n<img src="test.jpg" alt="test">\n') </nowiki> <nowiki># index.t:9 (via base.t:7)</nowiki>
     <nowiki>_append(b'\n</body>\n</html>') </nowiki> <nowiki># base.t:9</nowiki>
     return _utf8('').join(_buffer)  <nowiki># base.t:0</nowiki>

 <nowiki>#!/usr/bin/env python</nowiki>
 <nowiki># -*- coding: UTF-8 -*-</nowiki>
 """

 """
 __author__ = ''
 __version__ = ''

 title = request.path

 <nowiki>#!/usr/bin/env python</nowiki>
 <nowiki># -*- coding: UTF-8 -*-</nowiki>
 """

 """
 __author__ = ''
 __version__ = ''

 import os

 hello = 'hello'

 def world():
     return 'world'


= tore.web.JsonHandler =
为Ajax和RESTful Web服务优化的Json处理器，继承自tornado.web.RequestHandler，增加以下方法：

# write_object(self, obj)：把Python对象输出为Json格式，Content Type设置为“application/json; charset=UTF-8”
# write_text(self, txt)：直接输出Json格式的文本，Content Type设置为“application/json; charset=UTF-8”。注意此方法不对文本做编码和语法检查
# get_params_as_dict(self)：获取字典包装的请求参数，包含URL附加的查询字符串（例如GET请求）和HTTP请求报文体（例如POST请求）中的内容
# get_body_as_text(self)：获取纯文本格式的HTTP请求报文体，默认解码自UTF-8
# get_body_as_object(self)：将Json格式的HTTP请求报文体转化为Python对象，注意使用jQuery.ajax()提交时，Json字符串应该放在data参数中，并且processData参数必须设置为false，否则jQuery会“自作聪明”地把data中的内容进行URL格式的转码

= tore.web.authenticated修饰符 =
用于修饰RequestHandler中的get、post等方法，对这些请求进行HTTP基本身份认证（HTTP Basic Authentication），认证调用的的函数详见tore.start_server()的设置参数。

tore增强的模板处理器已经加入了该修饰。

= tore.web.authorized修饰符 =
用于修饰RequestHandler中的get、post等方法，对这些请求进行鉴权，鉴权调用的的函数详见tore.start_server()的设置参数。

tore增强的模板处理器已经加入了该修饰。

这两个修饰符可以结合使用，同时对请求进行认证和鉴权，例如：

     @tore.web.authenticated
     @tore.web.authorized
     def get(self, *args, **kwargs):
         ...

= Json Messaging消息引擎 =
原先使用Node.JS编写的Json Messaging消息服务现已经用Python完全重写并嵌入到tornado中，参见tore.start_server()的设置参数表。

在服务程序内部可以直接调用tore.messaging.exchange.push(message, destination)发送消息，就不需要通过TCP或者UDP了。

帧格式的定义参见Json Messaging文档。

下面的jquery.messaging.js程序提供了通过WebSocket发布订阅消息服务的功能，目前支持新版本的Chrome和Firefox浏览器：

 /*!
  <nowiki>* Json Messaging消息服务客户端</nowiki>
  <nowiki>* 具有断连自动恢复功能，参见initWs()函数</nowiki>
  <nowiki>* @author shajunxing</nowiki>
  <nowiki>* @version 0.0.0.0</nowiki>
  <nowiki>*/</nowiki>

 (function ($) {
     /**
      <nowiki>* 获取消息客户端</nowiki>
      <nowiki>* 消息客户段具有下面一些事件：</nowiki>
      <nowiki>* onOpen() 客户端已连接</nowiki>
      <nowiki>* onError() WebSocket的onerror和消息服务器的错误帧都将触发该事件</nowiki>
      <nowiki>* onClose() 客户端已关闭事件</nowiki>
      <nowiki>* @return {*}</nowiki>
      <nowiki>*/</nowiki>
     $.messageClient = function () {
         window.WebSocket = window.WebSocket || window.MozWebSocket;

         if (!window.WebSocket) {
             // 浏览器不支持WebSocket
             return null;
         }

         var client = {};

         // 局部消息回调函数，可针对每一个订阅单独定义回调函数
         client.messageListeners = {};
         // 打开、关闭和错误回调函数
         client.openListener = null;
         client.closeListener = null;
         client.errorListener = null;

         /**
          <nowiki>* 初始化client对象中的ws成员并和client绑定</nowiki>
          <nowiki>* 此函数将在连接错误或关闭后定时自动调用以自动重新连接</nowiki>
          <nowiki>*/</nowiki>
         client.initWs = function () {
             if (location.protocol == 'https:') {
                 client.ws = new WebSocket('wss://' + location.host + '/messaging');
             } else {
                 client.ws = new WebSocket('ws://' + location.host + '/messaging');
             }

             client.ws.onmessage = function (message) {
                 try {
                     var parsed = JSON.parse(message.data);
                     switch (parsed.type) {
                         case 'message':
                             // 消息帧
                             // 局部回调函数
                             for (var destination in client.messageListeners) {
                                 if (client.messageListeners.hasOwnProperty(destination)) {
                                     <nowiki>if (client.messageListeners[destination]['pattern'].exec(parsed.match[0])) {</nowiki>
                                         <nowiki>if (client.messageListeners[destination]['listener']) {</nowiki>
                                             <nowiki>client.messageListeners[destination]['listener'](parsed.content, parsed.match);</nowiki>
                                         }
                                     }
                                 }
                             }
                             break;
                         case 'error':
                             // 错误帧
                             console.warn('Server error: %s', parsed);
                             if (client.errorListener) {
                                 client.errorListener();
                             }
                             break;
                         default:
                             // 未知帧
                             console.warn('Unknown message type %s', parsed.type);
                             break;
                     }
                 } catch (e) {
                     console.warn(e);
                 }
             };

             client.ws.onopen = function () {
                 if (client.openListener) {
                     client.openListener();
                 }
             };

             client.ws.onclose = function () {
                 console.debug('websocket closed');
                 if (client.closeListener) {
                     client.closeListener();
                 }
                 // 等待尝试重新连接
                 // TODO: 是否会引起内存泄露？
                 setTimeout(client.initWs, 3000);
             };

             client.ws.onerror = function () {
                 console.debug('websocket error');
                 if (client.errorListener) {
                     client.errorListener();
                 }
                 // 关闭连接
                 client.ws.close();
             };
         };

         client.onOpen = function (listener) {
             client.openListener = listener;
         };

         client.onClose = function (listener) {
             client.closeListener = listener;
         };

         client.onError = function (listener) {
             client.errorListener = listener;
         };

         /**
          <nowiki>* 发布消息</nowiki>
          <nowiki>* @param content 内容</nowiki>
          <nowiki>* @param destination 目的地</nowiki>
          <nowiki>*/</nowiki>
         client.publish = function (content, destination) {
             client.ws.send(JSON.stringify({
                 type:'publish',
                 destination:destination,
                 content:content
             }));
         };

         /**
          <nowiki>* 订阅消息</nowiki>
          <nowiki>* @param destination 目的地（可以是正则表达式）</nowiki>
          <nowiki>* @param listener(content, match) 该订阅的回调函数</nowiki>
          <nowiki>*/</nowiki>
         client.subscribe = function (destination, listener) {
             <nowiki>client.messageListeners[destination] = {};</nowiki>
             // 预编译
             <nowiki>client.messageListeners[destination]['pattern'] = new RegExp(destination);</nowiki>
             <nowiki>client.messageListeners[destination]['listener'] = listener;</nowiki>
             client.ws.send(JSON.stringify({
                 type:'subscribe',
                 destination:destination
             }));
         };

         /**
          <nowiki>* 取消订阅消息</nowiki>
          <nowiki>* @param destination 目的地</nowiki>
          <nowiki>*/</nowiki>
         client.unsubscribe = function (destination) {
             <nowiki>delete client.messageListeners[destination];</nowiki>
             client.ws.send(JSON.stringify({
                 type:'unsubscribe',
                 destination:destination
             }));
         };

         /**
          <nowiki>* 关闭连接</nowiki>
          <nowiki>*/</nowiki>
         client.close = function () {
             client.ws.close();
         };

         // 第一次初始化
         client.initWs();

         return client;
     };
 }(jQuery));



